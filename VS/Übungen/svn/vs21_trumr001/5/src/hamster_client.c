/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "hamster.h"
#include "hamsterlib.h"

CLIENT *clnt;

void hmstr_rpc_init(char *hostname)
{
    clnt = clnt_create (hostname, HAMSTER_RPC, HMSTR_COLLECT_VERS, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (hostname);
		exit (1);
	}
}

void hmstr_rpc_terminate(void)
{
    clnt_destroy(clnt);
}

int32_t hmstr_new(
	const char* owner_name,		/**< [in] name of hamster's owner     */
	const char* hamster_name,	/**< [in] name of hamster             */
	uint16_t treats			/**< [in] initial provision of treats */
	)
{
	printf("attempting to call hmstr_new_rpc...\n");
	hmstr_new_out  *result_7;
	hmstr_new_in  hmstr_new_rpc_1_arg;

	hmstr_new_rpc_1_arg.hamster = (char *)hamster_name;
	hmstr_new_rpc_1_arg.owner = (char *)owner_name;
	hmstr_new_rpc_1_arg.treats = treats;

	result_7 = hmstr_new_rpc_1(&hmstr_new_rpc_1_arg, clnt);
	if (result_7 == (hmstr_new_out *) NULL) {
		clnt_perror (clnt, "call failed\n");
	}

	return result_7->id;
};

int32_t hmstr_lookup(
	const char* owner_name,		/**< [in] name of hamster's owner */
	const char* hamster_name	/**< [in] name of hamster         */
	)
{
	hmstr_lookup_out  *result_5;
	hmstr_lookup_in  hmstr_lookup_rpc_1_arg;

	hmstr_lookup_rpc_1_arg.hamster = (char *)hamster_name;
	hmstr_lookup_rpc_1_arg.hamster = (char *)owner_name;

	result_5 = hmstr_lookup_rpc_1(&hmstr_lookup_rpc_1_arg, clnt);
	if (result_5 == (hmstr_lookup_out *) NULL) {
		clnt_perror (clnt, "call failed\n");
	}

	return result_5->id;
};

int32_t hmstr_directory(
    int32_t* fdptr,	/**< [in/out] pointer where to store the open file handle across 
    * calls */
	const char* owner_name,		/**< [in] name of hamster's owner or NULL if not specified */
	const char* hamster_name	/**< [in] name of hamster or NULL if not specified        */
	)
{
	printf("preparing rpc call directory...\n");
	hmstr_directory_out  *result_2;
	hmstr_directory_in  hmst_directory_rpc_1_arg;

	hmst_directory_rpc_1_arg.fdptr = *fdptr;

	printf("putting hamstername into place..\n");
	hmst_directory_rpc_1_arg.hamster = (char *)hamster_name;
	printf("checking for NULL\n");
	if(hmst_directory_rpc_1_arg.hamster == NULL)
		hmst_directory_rpc_1_arg.hamster = "";
		
	printf("putting ownername into place..\n");
	hmst_directory_rpc_1_arg.owner = (char *)owner_name;
	printf("checking for NULL\n");
	if(hmst_directory_rpc_1_arg.owner == NULL)
		hmst_directory_rpc_1_arg.owner = "";

	printf("calling dir with parameters:\n");
	printf("\tfdptr: %d\n", hmst_directory_rpc_1_arg.fdptr);

	result_2 = hmst_directory_rpc_1(&hmst_directory_rpc_1_arg, clnt);
	if (result_2 == (hmstr_directory_out *) NULL) {
		clnt_perror (clnt, "call failed");
	}

	*fdptr = result_2->fdptr;

	return result_2->id;
};

int32_t hmstr_howsdoing(
	int32_t ID,	/**< [in]  Hamster's unique ID */
	struct hmstr_state* state	/**< [out] pointer to data structure where to store information */
	)
{
	hmstr_howsdoing_out  *result_4;
	hmstr_howsdoing_in  hmstr_howsdoing_rpc_1_arg;

	hmstr_howsdoing_rpc_1_arg.id = ID;

	result_4 = hmstr_howsdoing_rpc_1(&hmstr_howsdoing_rpc_1_arg, clnt);
	if (result_4 == (hmstr_howsdoing_out *) NULL) {
		clnt_perror (clnt, "call failed");
	}

	state->cost = result_4->state.cost;
	state->rounds = result_4->state.rounds;
	state->treats_left = result_4->state.treats_left;

	return result_4->retVal;
};

int32_t hmstr_readentry(
	int32_t ID,		/**< [in] Hamster's unique ID             */
	char* owner,    /**< [out] Where to store name of Owner    */
	char* name,   	/**< [out] Where to store name of Hamster  */
	int16_t* price	/**< [out] Where to store cost (up to now) */
	)
{
	hmstr_readentry_out  *result_6;
	hmstr_readentry_in  hmstr_readentry_rpc_1_arg;

	hmstr_readentry_rpc_1_arg.id = ID;

	result_6 = hmstr_readentry_rpc_1(&hmstr_readentry_rpc_1_arg, clnt);
	if (result_6 == (hmstr_readentry_out *) NULL) {
		clnt_perror (clnt, "call failed");
	}

	strncpy(owner,result_6->owner,32);
	strncpy(name,result_6->name,32);
	*price = result_6->price;

	return result_6->treats;
};

int32_t hmstr_givetreats(
	int32_t ID,		/**< [in] Hamster's unique ID */
	uint16_t treats	/**< [in] How many treats to feed */
	)
{
	hmstr_givetreats_out  *result_3;
	hmstr_givetreats_in  hmstr_givetreats_rpc_1_arg;

	hmstr_givetreats_rpc_1_arg.id = ID;
	hmstr_givetreats_rpc_1_arg.treats = treats;

	result_3 = hmstr_givetreats_rpc_1(&hmstr_givetreats_rpc_1_arg, clnt);
	if (result_3 == (hmstr_givetreats_out *) NULL) {
		clnt_perror (clnt, "call failed");
	}

	return result_3->treats;
};

int32_t hmstr_collect(
	const char* owner_name		/**< [in] name of hamster owner */
	)
{
	hmstr_collect_out  *result_1;
	hmstr_collect_in  hmstr_collect_rpc_1_arg;

	static char owner[32];                                                     

	memset(&hmstr_collect_rpc_1_arg, '\0', sizeof(hmstr_collect_in));                                
	memset(owner, '\0', sizeof(owner)); 

	hmstr_collect_rpc_1_arg.owner = owner;

	printf("copying ownername into place...\n");
	strcpy(hmstr_collect_rpc_1_arg.owner, owner_name);

	result_1 = hmstr_collect_rpc_1(&hmstr_collect_rpc_1_arg, clnt);
	if (result_1 == (hmstr_collect_out *) NULL) {
		clnt_perror (clnt, "call failed");
	}

	return result_1->price;
};


void
hamster_rpc_1(char *host)
{
	
	hmstr_collect_out  *result_1;
	hmstr_collect_in  hmstr_collect_rpc_1_arg;
	hmstr_directory_out  *result_2;
	hmstr_directory_in  hmst_directory_rpc_1_arg;
	hmstr_givetreats_out  *result_3;
	hmstr_givetreats_in  hmstr_givetreats_rpc_1_arg;
	hmstr_howsdoing_out  *result_4;
	hmstr_howsdoing_in  hmstr_howsdoing_rpc_1_arg;
	hmstr_lookup_out  *result_5;
	hmstr_lookup_in  hmstr_lookup_rpc_1_arg;
	hmstr_readentry_out  *result_6;
	hmstr_readentry_in  hmstr_readentry_rpc_1_arg;
	hmstr_new_out  *result_7;
	hmstr_new_in  hmstr_new_rpc_1_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, HAMSTER_RPC, HMSTR_COLLECT_VERS, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	result_1 = hmstr_collect_rpc_1(&hmstr_collect_rpc_1_arg, clnt);
	if (result_1 == (hmstr_collect_out *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	result_2 = hmst_directory_rpc_1(&hmst_directory_rpc_1_arg, clnt);
	if (result_2 == (hmstr_directory_out *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	result_3 = hmstr_givetreats_rpc_1(&hmstr_givetreats_rpc_1_arg, clnt);
	if (result_3 == (hmstr_givetreats_out *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	result_4 = hmstr_howsdoing_rpc_1(&hmstr_howsdoing_rpc_1_arg, clnt);
	if (result_4 == (hmstr_howsdoing_out *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	result_5 = hmstr_lookup_rpc_1(&hmstr_lookup_rpc_1_arg, clnt);
	if (result_5 == (hmstr_lookup_out *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	result_6 = hmstr_readentry_rpc_1(&hmstr_readentry_rpc_1_arg, clnt);
	if (result_6 == (hmstr_readentry_out *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	result_7 = hmstr_new_rpc_1(&hmstr_new_rpc_1_arg, clnt);
	if (result_7 == (hmstr_new_out *) NULL) {
		clnt_perror (clnt, "call failed");
	}
#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}


/*

auskommentiert da nicht ben√∂tigt und sonst 2 mains

int
main (int argc, char *argv[])
{
	char *host;

	if (argc < 2) {
		printf ("usage: %s server_host\n", argv[0]);
		exit (1);
	}
	host = argv[1];
	hamster_rpc_1 (host);
exit (0);
}

*/
