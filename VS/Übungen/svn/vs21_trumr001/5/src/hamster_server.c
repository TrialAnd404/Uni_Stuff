/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "hamster.h"
#include "hamsterlib.h"

hmstr_collect_out *
hmstr_collect_rpc_1_svc(hmstr_collect_in *argp, struct svc_req *rqstp)
{
	static hmstr_collect_out  result;

	printf("collect called\n");

	result.price = hmstr_collect(argp->owner);

	printf("accumulated cost: %d\n", result.price);
	return &result;
}

hmstr_directory_out *
hmst_directory_rpc_1_svc(hmstr_directory_in *argp, struct svc_req *rqstp)
{
	static hmstr_directory_out  result;

	result.fdptr = argp->fdptr;

	char* ownerptr = &argp->owner[0];
    char* hmstrptr = &argp->hamster[0];

	if(argp->owner[0] == '\0'){
    	ownerptr = NULL;
	}

    if(argp->hamster[0] == '\0'){
    	hmstrptr = NULL;
	}
	
	printf("directory called\n");
	printf("\tfdptr: %d\n", result.fdptr);

	result.id = hmstr_directory(&result.fdptr, ownerptr, hmstrptr);

	printf("result of call:\n");
	printf("\tfdptr: %d\n", result.fdptr);
	printf("\tid: %d\n", result.id);

	return &result;
}

hmstr_givetreats_out *
hmstr_givetreats_rpc_1_svc(hmstr_givetreats_in *argp, struct svc_req *rqstp)
{
	static hmstr_givetreats_out  result;

	printf("givetreats called\n");
	/*
	 * insert server code here
	 */

	result.treats = hmstr_givetreats(argp->id, argp->treats);

	return &result;
}

hmstr_howsdoing_out *
hmstr_howsdoing_rpc_1_svc(hmstr_howsdoing_in *argp, struct svc_req *rqstp)
{
	static hmstr_howsdoing_out  result;
	static struct hmstr_state state;

	printf("howsdoing called\n");

	result.retVal = hmstr_howsdoing(argp->id, &state);

	result.state.cost = state.cost;
	result.state.rounds = state.rounds;
	result.state.treats_left = state.treats_left;

	return &result;
}

hmstr_lookup_out *
hmstr_lookup_rpc_1_svc(hmstr_lookup_in *argp, struct svc_req *rqstp)
{
	static hmstr_lookup_out  result;

	printf("lookup called\n");
	printf("\towner: %s\n", argp->owner);
	printf("\thamster: %s\n", argp->hamster);
	
	result.id = hmstr_lookup(argp->owner, argp->hamster);

	return &result;
}

hmstr_readentry_out *
hmstr_readentry_rpc_1_svc(hmstr_readentry_in *argp, struct svc_req *rqstp)
{
	static hmstr_readentry_out  result;

	static char hamster[32];
	static char owner[32];                                                     
                               
	memset(owner, '\0', sizeof(owner)); 
	memset(hamster, '\0', sizeof(hamster));

	result.owner = owner;
	result.name = hamster;

	printf("readentry called\n");

	result.treats = hmstr_readentry(argp->id, owner, hamster, &result.price);
	strncpy(result.owner, owner, 32);
	strncpy(result.name, hamster, 32);

	printf("readentry complete:\n");
	printf("\towner: %s\n", owner);
	printf("\thamster: %s\n", hamster);
	printf("\tprice: %d\n", result.price);

	return &result;
}

hmstr_new_out *
hmstr_new_rpc_1_svc(hmstr_new_in *argp, struct svc_req *rqstp)
{
	static hmstr_new_out  result;

	printf("new called\n");
	printf("\towner: %s\n", argp->owner);
	printf("\thamster: %s\n", argp->hamster);
	printf("\ttreats: %d\n", argp->treats);
	/*
	 * insert server code here
	 */

	result.id = hmstr_new(argp->owner, argp->hamster, argp->treats);

	return &result;
}
