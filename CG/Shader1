// hier werden die Attribute-Variablen angelegt, diese
// werden bei jedem Aufruf des Vertex-Shaders mit den
// Werten f�r den einzelnen Vertex vorbelegt

// Objektkoordinate des Vertex
attribute  vec4 vPosition;

// Normale des Vertex (in Objektkoordinaten)
attribute  vec3 vNormal;

// Farbe des Vertex (f�r den Fall, dass keine 
// Beleuchtungsrechnung durchgef�hrt wird
attribute  vec4 vColor;

// Im Vertex-Shader wird ein Farbwert ermittelt und an
// den Fragment-Shader �bergeben
varying vec4 fColor;

// in den Uniform-Variablen stehen die Werte, die von
// au�en (d.h. der CPU-Seite) �bergeben werden und f�r
// alle Eckpunkte gleich sind

// Flag, ob Beleuchtungsrechnung durchgef�hrt werden soll
uniform bool lighting;

// Vorberechnung zur Beleuchtungsrechnung
uniform vec4 diffuseProduct;
uniform vec4 specularProduct;
uniform vec4 ambientProduct;
uniform float shininess;

// Position der Lichtquelle
uniform vec4 lightPosition;

// Model-Matrix (f�r Transformation Objektkoordinaten zu
// Weltkoordinaten)
uniform mat4 modelMatrix;

// View-Matrix (f�r Transformation Weltkoordinaten zu
// Kamerakoordinaten)
uniform mat4 viewMatrix;

// Projection-Matrix (f�r Transformation Kamerakoordinaten zu
// Clippingkoordinaten)
uniform mat4 projectionMatrix;

// Projection-Matrix (f�r Transformation der Normalen zu
// Kamerakoordinaten)
uniform mat4 normalMatrix;



void main()
{
  if (lighting) {
    // Beleuchtungsrechnung durchf�hren

  
    // Position Eckpunkt in Viewkoordinaten berechnen	
    vec3 pos = (viewMatrix * modelMatrix * vPosition).xyz;
    
    // Position der Lichtquelle
    vec3 light = (viewMatrix * lightPosition).xyz;

    // Vektor der L�nge 1 vom Eckpunkt zur Lichtquelle	
    vec3 L = normalize( light - pos );

    // Normale am Eckpunkt in Weltkoordinaten berechnen   
    vec3 N = (normalMatrix * vec4(vNormal, 0.0)).xyz;
    N = normalize(N);

    // Berechnung der diffusen Beleuchtung nach den Formeln
    // von Phong	
    float Kd = max( dot(L, N), 0.0 );
    vec3  diffuse = Kd*diffuseProduct.rgb;

    //Spekular nach Blinn
    vec3 V = normalize(-pos); 
    vec3 H = normalize(L+V); 
    float Ks = pow( max(dot(N, H), 0.0), shininess); // (cos)^sigma
    vec4  specular = Ks*specularProduct;
    if(dot(L, N) < 0.0) {
      specular = vec4(0.0,0.0,0.0,1.0);
    }

    // resultierende Farbe f�r Fragment-Shader bestimmen
    fColor = vec4(ambientProduct.xyz, 1.0) + diffuse.xyz + vec4(specular.xyz, 1.0);
    //Phong
 } else {

    // keine Beleuchtungsrechnung durchf�hren

    // der �bergebene Farbwert wird einfach an Fragment-Shader
    // weiter gereicht
    fColor = vColor;

 }

  // 	schlie�lich muss wie in jedem Vertex-Shader die
  // die Koordinate des Eckpunkts in Clipping-Koordinaten
  // umgerechnet werden. Das Ergebnis ist in die vordefinierte
  // Variable gl_Position zu schreiben
  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vPosition;

