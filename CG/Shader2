// hier werden die Attribute-Variablen angelegt, diese
// werden bei jedem Aufruf des Vertex-Shaders mit den
// Werten für den einzelnen Vertex vorbelegt

// Objektkoordinate des Vertex
attribute  vec4 vPosition;

// Normale des Vertex (in Objektkoordinaten)
attribute  vec3 vNormal;

// Farbe des Vertex (für den Fall, dass keine 
// Beleuchtungsrechnung durchgeführt wird
attribute  vec4 vColor;

// Im Vertex-Shader wird ein Farbwert ermittelt und an
// den Fragment-Shader übergeben
varying vec4 fColor;

// in den Uniform-Variablen stehen die Werte, die von
// außen (d.h. der CPU-Seite) übergeben werden und für
// alle Eckpunkte gleich sind

// Flag, ob Beleuchtungsrechnung durchgeführt werden soll
uniform bool lighting;

// Vorberechnung zur Beleuchtungsrechnung
uniform vec4 diffuseProduct;
uniform vec4 ambientProduct;
uniform vec4 specularProduct;
uniform float shininess;

// Position der Lichtquelle
uniform vec4 lightPosition;

// Model-Matrix (für Transformation Objektkoordinaten zu
// Weltkoordinaten)
uniform mat4 modelMatrix;

// View-Matrix (für Transformation Weltkoordinaten zu
// Kamerakoordinaten)
uniform mat4 viewMatrix;

// Projection-Matrix (für Transformation Kamerakoordinaten zu
// Clippingkoordinaten)
uniform mat4 projectionMatrix;

// Projection-Matrix (für Transformation der Normalen zu
// Kamerakoordinaten)
uniform mat4 normalMatrix;

// passthrough texCoord
attribute vec2 a_texcoord;
varying vec2 vTexCoord;

void main()
{
  if (lighting) {
    // Beleuchtungsrechnung durchführen

  
    // Position Eckpunkt in Viewkoordinaten berechnen	
    vec3 pos = (viewMatrix * modelMatrix * vPosition).xyz;
    
    // Position der Lichtquelle
    vec3 light = (viewMatrix * lightPosition).xyz;

    // Vektor der Länge 1 vom Eckpunkt zur Lichtquelle	
    vec3 E = normalize( light - pos );

    // Normale am Eckpunkt in Weltkoordinaten berechnen   
    vec3 N = (normalMatrix * vec4(vNormal, 0.0)).xyz;
    N = normalize(N);

    // Berechnung der diffusen Beleuchtung nach den Formeln von Phong
    float Kd = max( dot(E, N), 0.0 );
    vec3  diffuse = Kd*diffuseProduct.rgb;

    // Berechnung der spekularen Beleuchtung nach den Formeln von Phong-Blinn
    vec3 V = normalize(-pos); // entgegeggesetzter View-Vektor
    vec3 H = normalize(E+V); // halbvektor
    float Ks = pow( max(dot(N, H), 0.0), shininess); // (cos)^sigma
    vec4  specular = Ks*specularProduct;
    if(dot(E, N) < 0.0) {
      specular = vec4(0.0,0.0,0.0,1.0);
    }

    // resultierende Farbe für Fragment-Shader bestimmen
    fColor = vec4(ambientProduct.xyz + diffuse.xyz + specular.xyz, 1.0); // I_Phong
	
 } else {

    // keine Beleuchtungsrechnung durchführen

    // der übergebene Farbwert wird einfach an Fragment-Shader
    // weiter gereicht
    fColor = vColor;

 }

  // Pass the texcoord to the fragment shader.
  vTexCoord = a_texcoord;

  // 	schließlich muss wie in jedem Vertex-Shader die
  // die Koordinate des Eckpunkts in Clipping-Koordinaten
  // umgerechnet werden. Das Ergebnis ist in die vordefinierte
  // Variable gl_Position zu schreiben
  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vPosition;

}

